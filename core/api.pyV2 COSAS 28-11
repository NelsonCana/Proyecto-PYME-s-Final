# pymesec/core/api.py

from fastapi import FastAPI, Depends, HTTPException, status, WebSocket, WebSocketDisconnect, Header
from fastapi.middleware.cors import CORSMiddleware
from typing import List, Dict, Any, Optional
from sqlalchemy.orm import Session
from pydantic import BaseModel, EmailStr
from datetime import datetime
import asyncio
import io
import json
from passlib.context import CryptContext
from fastapi.responses import StreamingResponse

# ReportLab para PDF
from reportlab.pdfgen import canvas
from reportlab.lib.pagesizes import letter
from reportlab.lib import colors

# BD y Modelos
from .db import get_db, init_db, ScanResult as DBScanResult, User as DBUser

# --- IMPORTS DE ESCÁNERES ---
from scanners.net.ping import check_ping
from scanners.net.custom_ports import scan_ports_native
from scanners.net.tls import tls_info
from scanners.web.headers import check_headers
from scanners.runner import scan_nuclei, scan_dirsearch, scan_sqlmap, scan_xsstrike

# NOTA: Se eliminó la importación de core.ai para evitar errores

app = FastAPI(title="PYMESec Security Evaluator API")
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

# --- CORS ---
origins = ["*"]
app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# --- SCHEMAS ---
class UserSchema(BaseModel):
    id: int
    name: str
    email: EmailStr
    company_name: str
    class Config: from_attributes = True

class LoginRequest(BaseModel):
    email: EmailStr
    password: str

class ConfigUpdate(BaseModel):
    sector: str
    network_size: int
    main_server_ip: Optional[str] = None

class RegisterRequest(LoginRequest):
    name: str
    companyName: str

class ScanParams(BaseModel):
    ip_range: str
    scan_type: str

class ScanResultResponse(BaseModel):
    id: int
    host: Optional[str] = None
    scan_time: Optional[datetime] = None
    status: str
    results: Dict[str, Any]
    class Config: from_attributes = True

# --- UTILIDADES ---
def verify_password(plain, hashed): return pwd_context.verify(plain, hashed)
def get_password_hash(pwd): return pwd_context.hash(pwd)

active_connections: Dict[int, WebSocket] = {}

async def push_status(user_id: int, msg: str, status: str, scan_id: int):
    if user_id in active_connections:
        try:
            await active_connections[user_id].send_json({
                "status": status, "message": msg, "scanId": scan_id
            })
        except: pass

# --- CEREBRO CENTRAL (HÍBRIDO + PLAN B) ---
async def run_scan_real(user_id: int, scan_id: int, target: str, db: Session):
    try:
        host = target.replace("https://", "").replace("http://", "").split("/")[0]
        url = target if target.startswith("http") else f"http://{target}"
        findings = []

        # ---------------------------------------------------------
        # FASE 1: RECONOCIMIENTO (PING + TCP PLAN B)
        # ---------------------------------------------------------
        
        # A. Intentar Ping
        await push_status(user_id, f"Verificando disponibilidad de {host}...", "Running", scan_id)
        is_alive = await check_ping(host)

        # B. Si falla Ping, probar Plan B (TCP)
        if not is_alive:
            await push_status(user_id, "Ping bloqueado. Intentando conexión TCP directa (Plan B)...", "Running", scan_id)
            fallback_check = await scan_ports_native(host)
            
            if len(fallback_check) > 0:
                is_alive = True
                await push_status(user_id, "Objetivo detectado por TCP (Firewall evadido).", "Running", scan_id)
            else:
                error_msg = f"El objetivo {host} parece inactivo (Ni Ping ni TCP responden)."
                scan_row = db.query(DBScanResult).filter(DBScanResult.id == scan_id).first()
                if scan_row:
                    scan_row.status = "Error"
                    scan_row.results = {"error": "Host Unreachable", "summary": "Objetivo inaccesible."}
                    db.commit()
                await push_status(user_id, error_msg, "Error", scan_id)
                return

        # C. Escaneo de Puertos Real
        await push_status(user_id, "Analizando superficie de ataque (Sockets Nativos)...", "Running", scan_id)
        open_ports = await scan_ports_native(host)
        
        if open_ports:
            findings.append({
                "severity": "INFO",
                "name": "Puertos Abiertos",
                "description": f"Detectados: {open_ports}",
                "mitigation": "Cerrar puertos innecesarios."
            })

        # ---------------------------------------------------------
        # FASE 2: ANÁLISIS WEB
        # ---------------------------------------------------------
        is_web = any(p in open_ports for p in [80, 443, 8000, 8080, 3000, 5000, 50000, 50001]) or target.startswith("http")

        if is_web:
            # D. Headers (Nativo)
            await push_status(user_id, "Analizando cabeceras HTTP...", "Running", scan_id)
            headers_res = await check_headers(url)
            for h in headers_res.get("findings", []):
                findings.append({
                    "severity": "MEDIA",
                    "name": "Cabecera de Seguridad Faltante",
                    "description": h,
                    "mitigation": "Configurar headers en servidor web"
                })

            # E. TLS (Nativo)
            if 443 in open_ports or url.startswith("https"):
                tls_res = await tls_info(host)
                if tls_res:
                    findings.append({
                        "severity": "INFO",
                        "name": "Info TLS/SSL",
                        "description": f"Emisor: {tls_res.get('issuer')}",
                        "mitigation": "N/A"
                    })

            # ---------------------------------------------------------
            # FASE 3: ATAQUE PROFUNDO (Censurado/Profesional)
            # ---------------------------------------------------------
            await push_status(user_id, "Iniciando motores de análisis heurístico y detección de anomalías...", "Running", scan_id)
            
            results_parallel = await asyncio.gather(
                scan_nuclei(url),
                scan_dirsearch(url),
                scan_xsstrike(url)
            )
            for res in results_parallel: findings.extend(res)

            await push_status(user_id, "Ejecutando auditoría de integridad de Base de Datos y saneamiento de entradas...", "Running", scan_id)
            sql_vulns = await scan_sqlmap(url)
            findings.extend(sql_vulns)

        else:
            await push_status(user_id, "No es servicio Web. Saltando pruebas HTTP.", "Running", scan_id)

        # ---------------------------------------------------------
        # FASE 4: GUARDAR (SIN IA)
        # ---------------------------------------------------------
        final_results = { 
            "vulnerabilities": findings, 
            "scan_meta": { "host": host, "ports": open_ports } 
        }

        scan_row = db.query(DBScanResult).filter(DBScanResult.id == scan_id).first()
        if scan_row:
            scan_row.results = final_results
            scan_row.status = "Completed"
            db.commit()

        await push_status(user_id, f"Escaneo completado. {len(findings)} hallazgos.", "Completed", scan_id)

    except Exception as e:
        print(f"FATAL: {e}")
        scan_row = db.query(DBScanResult).filter(DBScanResult.id == scan_id).first()
        if scan_row:
            scan_row.status = "Error"
            scan_row.results = {"error": str(e)}
            db.commit()
        await push_status(user_id, f"Error interno: {str(e)}", "Error", scan_id)
    finally:
        db.close()

# --- ENDPOINTS RESTANTES ---
@app.on_event("startup")
def startup(): init_db()

@app.post("/api/v1/auth/register")
def reg(r: RegisterRequest, db: Session = Depends(get_db)):
    if db.query(DBUser).filter(DBUser.email == r.email).first(): raise HTTPException(400, "Email existe")
    u = DBUser(name=r.name, email=r.email, hashed_password=get_password_hash(r.password), company_name=r.companyName)
    db.add(u); db.commit(); db.refresh(u)
    return {"msg": "OK"}

@app.post("/api/v1/auth/login")
def login(r: LoginRequest, db: Session = Depends(get_db)):
    u = db.query(DBUser).filter(DBUser.email == r.email).first()
    if not u or not verify_password(r.password, u.hashed_password): raise HTTPException(401, "Bad creds")
    return {"token": f"fake_jwt_token_{u.id}", "user": UserSchema.model_validate(u).model_dump()}

@app.get("/api/v1/user/me", response_model=UserSchema)
def me(authorization: str = Header(None), db: Session = Depends(get_db)):
    try:
        uid = int(authorization.split(" ")[1].split("_")[-1])
        return db.query(DBUser).filter(DBUser.id == uid).first()
    except: raise HTTPException(401, "Token error")

@app.get("/api/v1/evaluation/history", response_model=List[ScanResultResponse])
def hist(db: Session = Depends(get_db)):
    return db.query(DBScanResult).order_by(DBScanResult.scan_time.desc()).all()

@app.post("/api/v1/evaluation/start")
async def start(p: ScanParams, authorization: str = Header(None), db: Session = Depends(get_db)):
    try: uid = int(authorization.split(" ")[1].split("_")[-1])
    except: uid = 1 
    new_scan = DBScanResult(status="Pending", results={}, user_id=uid, host=p.ip_range)
    db.add(new_scan); db.commit(); db.refresh(new_scan)
    asyncio.create_task(run_scan_real(uid, new_scan.id, p.ip_range, get_db().__next__()))
    return {"message": "Iniciado", "scanId": new_scan.id}

@app.get("/api/v1/scan/{scan_id}", response_model=ScanResultResponse)
def detail(scan_id: int, db: Session = Depends(get_db)):
    res = db.query(DBScanResult).filter(DBScanResult.id == scan_id).first()
    if not res: raise HTTPException(404)
    return res

@app.get("/api/v1/config/company")
def get_company_config():
    return {"sector": "tecnologia", "network_size": 10, "main_server_ip": "127.0.0.1"}

@app.post("/api/v1/config/company")
def update_company_config(config: ConfigUpdate):
    return {"message": "Configuración guardada"}

@app.get("/api/v1/reports/{scan_id}/download")
def download_report_pdf(scan_id: int, db: Session = Depends(get_db)):
    scan = db.query(DBScanResult).filter(DBScanResult.id == scan_id).first()
    if not scan: raise HTTPException(404, "Reporte no encontrado")

    vulns = scan.results.get("vulnerabilities", [])
    # Eliminamos la referencia a la IA
    
    buffer = io.BytesIO()
    c = canvas.Canvas(buffer, pagesize=letter)
    width, height = letter
    
    # Header
    c.setFillColor(colors.darkblue)
    c.rect(0, height - 100, width, 100, fill=True, stroke=False)
    c.setFillColor(colors.white)
    c.setFont("Helvetica-Bold", 24)
    c.drawString(50, height - 50, "REPORTE PYMESEC")
    c.setFont("Helvetica", 12)
    c.drawString(50, height - 80, f"Target: {scan.host} | {scan.scan_time}")

    y = height - 150

    # Tech Section
    c.setFillColor(colors.black)
    c.setFont("Helvetica-Bold", 14)
    c.drawString(50, y, f"Detalles Técnicos ({len(vulns)}):")
    y -= 30

    c.setFont("Helvetica", 10)
    for v in vulns:
        if y < 100: c.showPage(); y = height - 50
        severity = v.get('severity', 'INFO').upper()
        name = v.get('name', 'Evento')
        
        color = colors.black
        if 'CRITIC' in severity: color = colors.red
        elif 'ALTA' in severity: color = colors.orange
        elif 'MEDIA' in severity: color = colors.brown
        elif 'INFO' in severity: color = colors.blue
        
        c.setFillColor(color)
        c.drawString(50, y, f"[{severity}] {name}")
        c.setFillColor(colors.gray)
        clean_desc = str(v.get('description', ''))[:95].replace('\n', ' ') + "..."
        c.drawString(50, y - 15, clean_desc)
        y -= 40

    c.save()
    buffer.seek(0)
    return StreamingResponse(
        buffer, 
        media_type="application/pdf", 
        headers={"Content-Disposition": f"attachment; filename=report_{scan_id}.pdf"}
    )

@app.websocket("/ws/status/{user_id}")
async def ws_endpoint(websocket: WebSocket, user_id: int):
    await websocket.accept()
    active_connections[user_id] = websocket
    try:
        while True: await websocket.receive_text()
    except WebSocketDisconnect:
        del active_connections[user_id]
