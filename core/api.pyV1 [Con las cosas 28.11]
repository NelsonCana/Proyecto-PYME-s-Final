# pymesec/core/api.py

from fastapi import FastAPI, Depends, HTTPException, status, WebSocket, WebSocketDisconnect, Header
from fastapi.middleware.cors import CORSMiddleware
from typing import List, Dict, Any, Optional
from sqlalchemy.orm import Session
from pydantic import BaseModel, EmailStr
from datetime import datetime
import asyncio
import io
import json
from passlib.context import CryptContext
from fastapi.responses import StreamingResponse

# ReportLab para PDF
from reportlab.pdfgen import canvas
from reportlab.lib.pagesizes import letter
from reportlab.lib import colors

# BD y Modelos
from .db import get_db, init_db, ScanResult as DBScanResult, User as DBUser

# ==========================================
# ZONA DE IMPORTACIÓN HÍBRIDA
# ==========================================

# 1. TUS ESCÁNERES NATIVOS (Ligeros y Rápidos - Python Puro)
from scanners.net.ping import check_ping
from scanners.net.custom_ports import scan_ports_native
from scanners.net.tls import tls_info           # <--- RECUPERADO
from scanners.web.headers import check_headers  # <--- RECUPERADO

# 2. LA ARTILLERÍA PESADA (Orquestación de Herramientas Externas)
# Reemplazamos tus check_sqli/xss/enum antiguos por versiones profesionales
from scanners.runner import scan_nuclei, scan_dirsearch, scan_sqlmap, scan_xsstrike

app = FastAPI(title="PYMESec Security Evaluator API")
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

# --- CORS ---
origins = ["*"]
app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# --- SCHEMAS ---
class UserSchema(BaseModel):
    id: int
    name: str
    email: EmailStr
    company_name: str
    class Config: from_attributes = True

class LoginRequest(BaseModel):
    email: EmailStr
    password: str

class ConfigUpdate(BaseModel):
    sector: str
    network_size: int
    main_server_ip: Optional[str] = None

class RegisterRequest(LoginRequest):
    name: str
    companyName: str

class ScanParams(BaseModel):
    ip_range: str
    scan_type: str

class ScanResultResponse(BaseModel):
    id: int
    host: Optional[str] = None
    scan_time: Optional[datetime] = None
    status: str
    results: Dict[str, Any]
    class Config: from_attributes = True

# --- UTILIDADES ---
def verify_password(plain, hashed): return pwd_context.verify(plain, hashed)
def get_password_hash(pwd): return pwd_context.hash(pwd)

active_connections: Dict[int, WebSocket] = {}

async def push_status(user_id: int, msg: str, status: str, scan_id: int):
    if user_id in active_connections:
        try:
            await active_connections[user_id].send_json({
                "status": status, "message": msg, "scanId": scan_id
            })
        except: pass

# ==========================================
# CEREBRO CENTRAL (LOGICA DE NEGOCIO)
# ==========================================
async def run_scan_real(user_id: int, scan_id: int, target: str, db: Session):
    try:
        # Preparar host y url
        host = target.replace("https://", "").replace("http://", "").split("/")[0]
        url = target if target.startswith("http") else f"http://{target}"
        
        findings = []

        # ---------------------------------------------------------
        # FASE 1: VALIDACIÓN Y RED (Tu Código Nativo)
        # ---------------------------------------------------------
        
        # A. Ping
        await push_status(user_id, f"Verificando disponibilidad de {host}...", "Running", scan_id)
	is_alive = await check_ping(host)

	if not is_alive:
            await push_status(user_id, "Ping bloqueado. Intentando conexión TCP directa (Plan B)...", "Running", scan_id)
            # Usamos tu escáner de puertos nativo para ver si hay algo abierto
            # Esto es muy rápido y nos dirá la verdad
            fallback_check = await scan_ports_native(host)
            
            if len(fallback_check) > 0:
                is_alive = True # ¡Está vivo! Solo bloqueaba el ping.
                await push_status(user_id, "Objetivo detectado por TCP (Firewall evadido).", "Running", scan_id)
            else:
                # Ahora sí, si no hay ping Y no hay puertos abiertos, está muerto.
                error_msg = f"El objetivo {host} parece inactivo (Ni Ping ni TCP responden)."
                print(f"Abortando: {error_msg}")
                
                scan_row = db.query(DBScanResult).filter(DBScanResult.id == scan_id).first()
                if scan_row:
                    scan_row.status = "Error"
                    scan_row.results = {"error": "Host Unreachable", "summary": "Objetivo inaccesible."}
                    db.commit()
                
                await push_status(user_id, error_msg, "Error", scan_id)
                return # Detener ejecución

        # B. Puertos (Sockets Nativos)
        await push_status(user_id, "Escaneando puertos (Sockets Nativos)...", "Running", scan_id)
        open_ports = await scan_ports_native(host)
        
        if open_ports:
            findings.append({
                "severity": "INFO",
                "name": "Puertos Abiertos",
                "description": f"Detectados: {open_ports}",
                "mitigation": "Cerrar puertos innecesarios."
            })

        # ---------------------------------------------------------
        # FASE 2: ANÁLISIS WEB LIGERO (Tus Scripts Python)
        # ---------------------------------------------------------
        
        # Detectamos si es web (puertos 80, 443, etc)
        is_web = any(p in open_ports for p in [80, 443, 8000, 8080, 3000, 5000, 50000, 50001]) or target.startswith("http")

        if is_web:
            # C. Headers de Seguridad (Tu script original)
            await push_status(user_id, "Analizando cabeceras HTTP (Python Nativo)...", "Running", scan_id)
            headers_res = await check_headers(url)
            # Adaptamos tu resultado antiguo al nuevo formato
            for h in headers_res.get("findings", []):
                findings.append({
                    "severity": "MEDIA",
                    "name": "Cabecera de Seguridad Faltante",
                    "description": h,
                    "mitigation": "Configurar headers en Nginx/Apache"
                })

            # D. Certificados TLS (Tu script original, si aplica HTTPS)
            if 443 in open_ports or url.startswith("https"):
                await push_status(user_id, "Analizando certificado SSL/TLS...", "Running", scan_id)
                tls_res = await tls_info(host)
                if tls_res:
                    findings.append({
                        "severity": "INFO",
                        "name": "Información TLS/SSL",
                        "description": f"Emisor: {tls_res.get('issuer')}, Expira: {tls_res.get('expires')}",
                        "mitigation": "Verificar renovación automática"
                    })

            # ---------------------------------------------------------
            # FASE 3: ARTILLERÍA PESADA (Orquestación Externa)
            # ---------------------------------------------------------
            await push_status(user_id, "Iniciando motores de análisis heurístico y detección de anomalías...", "Running", scan_id)
            
            # Lanzamos en paralelo las herramientas rápidas
            results_parallel = await asyncio.gather(
                scan_nuclei(url),
                scan_dirsearch(url),
                scan_xsstrike(url)
            )
            
            for res in results_parallel:
                findings.extend(res)

            # Lanzamos SQLMap (Secuencial, más lento)
            await push_status(user_id, "Ejecutando auditoría de integridad de Base de Datos y saneamiento de entradas...", "Running", scan_id)
            sql_vulns = await scan_sqlmap(url)
            findings.extend(sql_vulns)

        else:
            await push_status(user_id, "No es un servicio Web. Omitiendo pruebas HTTP.", "Running", scan_id)

        # ---------------------------------------------------------
        # FASE 4: GUARDADO Y REPORTE
        # ---------------------------------------------------------
        
        final_results = {
            "vulnerabilities": findings,
            "scan_meta": {
                "host": host,
                "ports": open_ports,
                "scan_type": "Hybrid (Native + External)"
            }
        }

        scan_row = db.query(DBScanResult).filter(DBScanResult.id == scan_id).first()
        if scan_row:
            scan_row.results = final_results
            scan_row.status = "Completed"
            db.commit()

        await push_status(user_id, f"Escaneo completado. {len(findings)} hallazgos.", "Completed", scan_id)

    except Exception as e:
        print(f"FATAL ERROR: {e}")
        scan_row = db.query(DBScanResult).filter(DBScanResult.id == scan_id).first()
        if scan_row:
            scan_row.status = "Error"
            scan_row.results = {"error": str(e)}
            db.commit()
        await push_status(user_id, f"Error interno: {str(e)}", "Error", scan_id)
    finally:
        db.close()

# --- ENDPOINTS ---

@app.on_event("startup")
def startup(): init_db()

@app.post("/api/v1/auth/register")
def reg(r: RegisterRequest, db: Session = Depends(get_db)):
    if db.query(DBUser).filter(DBUser.email == r.email).first(): raise HTTPException(400, "Email existe")
    u = DBUser(name=r.name, email=r.email, hashed_password=get_password_hash(r.password), company_name=r.companyName)
    db.add(u); db.commit(); db.refresh(u)
    return {"msg": "OK"}

@app.post("/api/v1/auth/login")
def login(r: LoginRequest, db: Session = Depends(get_db)):
    u = db.query(DBUser).filter(DBUser.email == r.email).first()
    if not u or not verify_password(r.password, u.hashed_password): raise HTTPException(401, "Bad creds")
    return {"token": f"fake_jwt_token_{u.id}", "user": UserSchema.model_validate(u).model_dump()}

@app.get("/api/v1/user/me", response_model=UserSchema)
def me(authorization: str = Header(None), db: Session = Depends(get_db)):
    try:
        uid = int(authorization.split(" ")[1].split("_")[-1])
        return db.query(DBUser).filter(DBUser.id == uid).first()
    except: raise HTTPException(401, "Token error")

@app.get("/api/v1/evaluation/history", response_model=List[ScanResultResponse])
def hist(db: Session = Depends(get_db)):
    return db.query(DBScanResult).order_by(DBScanResult.scan_time.desc()).all()

@app.post("/api/v1/evaluation/start")
async def start(p: ScanParams, authorization: str = Header(None), db: Session = Depends(get_db)):
    try:
        uid = int(authorization.split(" ")[1].split("_")[-1])
    except: uid = 1 
    
    new_scan = DBScanResult(status="Pending", results={}, user_id=uid, host=p.ip_range)
    db.add(new_scan); db.commit(); db.refresh(new_scan)
    
    # IMPORTANTE: Usamos una nueva sesión de BD para el proceso asíncrono
    asyncio.create_task(run_scan_real(uid, new_scan.id, p.ip_range, get_db().__next__()))
    
    return {"message": "Iniciado", "scanId": new_scan.id}

@app.get("/api/v1/scan/{scan_id}", response_model=ScanResultResponse)
def detail(scan_id: int, db: Session = Depends(get_db)):
    res = db.query(DBScanResult).filter(DBScanResult.id == scan_id).first()
    if not res: raise HTTPException(404)
    return res

@app.get("/api/v1/config/company")
def get_company_config():
    return {"sector": "tecnologia", "network_size": 10, "main_server_ip": "127.0.0.1"}

@app.post("/api/v1/config/company")
def update_company_config(config: ConfigUpdate):
    return {"message": "Configuración guardada"}

@app.get("/api/v1/reports/{scan_id}/download")
def download_report_pdf(scan_id: int, db: Session = Depends(get_db)):
    scan = db.query(DBScanResult).filter(DBScanResult.id == scan_id).first()
    if not scan: raise HTTPException(404, "Reporte no encontrado")

    vulns = scan.results.get("vulnerabilities", [])

    buffer = io.BytesIO()
    c = canvas.Canvas(buffer, pagesize=letter)
    width, height = letter

    # Diseño PDF Mejorado
    c.setFillColor(colors.darkblue)
    c.rect(0, height - 100, width, 100, fill=True, stroke=False)
    c.setFillColor(colors.white)
    c.setFont("Helvetica-Bold", 24)
    c.drawString(50, height - 50, "REPORTE PYMESEC")
    c.setFont("Helvetica", 12)
    c.drawString(50, height - 80, f"Target: {scan.host} | {scan.scan_time}")

    y = height - 150
    c.setFillColor(colors.black)
    c.setFont("Helvetica-Bold", 16)
    c.drawString(50, y, f"Hallazgos Totales: {len(vulns)}")
    y -= 30

    c.setFont("Helvetica", 10)
    for v in vulns:
        if y < 100: 
            c.showPage()
            y = height - 50

        severity = v.get('severity', 'INFO').upper()
        name = v.get('name', 'Evento')
        
        # Código de colores
        if 'CRITIC' in severity: c.setFillColor(colors.red)
        elif 'ALT' in severity: c.setFillColor(colors.orange)
        elif 'MED' in severity: c.setFillColor(colors.brown)
        else: c.setFillColor(colors.blue)
        
        c.drawString(50, y, f"[{severity}] {name}")
        c.setFillColor(colors.gray)
        
        # Recortar descripciones largas
        clean_desc = str(v.get('description', ''))[:100].replace('\n', ' ')
        c.drawString(50, y - 15, f"{clean_desc}...")
        
        y -= 40

    c.save()
    buffer.seek(0)
    return StreamingResponse(
        buffer, 
        media_type="application/pdf", 
        headers={"Content-Disposition": f"attachment; filename=pymesec_report_{scan_id}.pdf"}
    )

@app.websocket("/ws/status/{user_id}")
async def ws_endpoint(websocket: WebSocket, user_id: int):
    await websocket.accept()
    active_connections[user_id] = websocket
    try:
        while True: await websocket.receive_text()
    except WebSocketDisconnect:
        del active_connections[user_id]
